import java.util.ArrayList;
import java.util.Iterator;
import java.util.Scanner;

/**
 *
 * @author Veronica
 */
public class PNCGUI extends javax.swing.JFrame
{

    /**
     * Creates new form PNCGUI
     */
    public PNCGUI()
    {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents()
    {

        labelNumPlaces = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        labelIntMark = new javax.swing.JLabel();
        numPlaces = new javax.swing.JTextField();
        numTrans = new javax.swing.JTextField();
        initMarking = new javax.swing.JTextField();
        jSeparator1 = new javax.swing.JSeparator();
        jScrollPane1 = new javax.swing.JScrollPane();
        errorMes = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();
        button1 = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jSeparator2 = new javax.swing.JSeparator();
        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        jLabel11 = new javax.swing.JLabel();
        transEnterLabel = new javax.swing.JLabel();
        transEnterField = new javax.swing.JTextField();
        jLabel12 = new javax.swing.JLabel();
        jLabel13 = new javax.swing.JLabel();
        jLabel14 = new javax.swing.JLabel();
        button2 = new javax.swing.JButton();
        jSeparator3 = new javax.swing.JSeparator();
        jLabel15 = new javax.swing.JLabel();
        jLabel16 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        reachableMarkings = new javax.swing.JTextArea();
        entering = 0;
        part1safe = false;
        part0safe = true;
        part3safe = true;
        part4safe = false;
        gotPT = false;

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Justonicete:  The Petri Net Reachability Calculator");
        setBackground(new java.awt.Color(245, 245, 245));

        labelNumPlaces.setText("Number of Places: ");

        jLabel2.setText("Number of Transitions: ");

        labelIntMark.setText("Initial Marking: ");

        numTrans.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                numTransActionPerformed(evt);
            }
        });

        errorMes.setColumns(20);
        errorMes.setForeground(new java.awt.Color(250, 0, 0));
        errorMes.setRows(5);
        jScrollPane1.setViewportView(errorMes);

        jLabel1.setText("Error Messages");

        button1.setText("Enter ");
        button1.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                button1ActionPerformed(evt);
            }
        });

        jLabel3.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel3.setText("Part One: ");

        jLabel4.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel4.setText("Part Two: ");

        jLabel5.setFont(new java.awt.Font("Tahoma", 1, 16)); // NOI18N
        jLabel5.setText("- Complete Form in Order to Obtain Reachable Markings - ");

        jLabel6.setText("(Calculations will not continue to the next part until previous part is completed.) ");

        jLabel7.setFont(new java.awt.Font("Tahoma", 1, 16)); // NOI18N
        jLabel7.setText("Directions: ");

        jLabel8.setText("1.) Enter number of places as a whole number.");

        jLabel9.setText("2.) Enter number of transitions as a whole number.");

        jLabel10.setText("3.) Enter initial marking with whole numbers seperated ");

        jLabel11.setText("by commas or spaces.");

        transEnterLabel.setText("Enter Transitions for: ");

        transEnterField.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                transEnterFieldActionPerformed(evt);
            }
        });

        jLabel12.setFont(new java.awt.Font("Tahoma", 1, 16)); // NOI18N
        jLabel12.setText("Directions: ");

        jLabel13.setText("4.) Enter transition I/O with whole numbers seperated ");

        jLabel14.setText("by commas or spaces.");

        button2.setText("Enter");
        button2.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                button2ActionPerformed(evt);
            }
        });

        jLabel15.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel15.setText("Part Three:");

        jLabel16.setText("Your reachable markings are: ");

        reachableMarkings.setColumns(20);
        reachableMarkings.setRows(5);
        jScrollPane2.setViewportView(reachableMarkings);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addComponent(jSeparator1)
                        .addComponent(jSeparator3)
                        .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addGroup(layout.createSequentialGroup()
                                                .addGap(25, 25, 25)
                                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                                        .addComponent(transEnterLabel)
                                                        .addComponent(jLabel4)
                                                        .addComponent(transEnterField, javax.swing.GroupLayout.PREFERRED_SIZE, 486, javax.swing.GroupLayout.PREFERRED_SIZE))
                                                .addGap(35, 35, 35)
                                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                                        .addComponent(jLabel11, javax.swing.GroupLayout.PREFERRED_SIZE, 339, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                        .addComponent(jLabel12)
                                                        .addComponent(jLabel13, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                                        .addGroup(layout.createSequentialGroup()
                                                .addGap(196, 196, 196)
                                                .addComponent(button2)
                                                .addGap(0, 0, Short.MAX_VALUE))
                                        .addGroup(layout.createSequentialGroup()
                                                .addComponent(jLabel6)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(jScrollPane1)))
                                .addContainerGap())
                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addContainerGap()
                                .addComponent(jLabel5)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jLabel1)
                                .addGap(144, 144, 144))
                        .addComponent(jSeparator2)
                        .addGroup(layout.createSequentialGroup()
                                .addGap(23, 23, 23)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(jLabel3)
                                        .addGroup(layout.createSequentialGroup()
                                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                                        .addGroup(layout.createSequentialGroup()
                                                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                                                        .addComponent(labelIntMark)
                                                                        .addComponent(jLabel2)
                                                                        .addComponent(labelNumPlaces))
                                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                                                        .addComponent(numPlaces)
                                                                        .addComponent(numTrans)
                                                                        .addComponent(initMarking, javax.swing.GroupLayout.PREFERRED_SIZE, 317, javax.swing.GroupLayout.PREFERRED_SIZE))
                                                                .addGap(29, 29, 29))
                                                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                                                .addComponent(button1)
                                                                .addGap(154, 154, 154)))
                                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                                        .addComponent(jLabel7)
                                                        .addComponent(jLabel8, javax.swing.GroupLayout.PREFERRED_SIZE, 339, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                        .addComponent(jLabel10)
                                                        .addComponent(jLabel14, javax.swing.GroupLayout.PREFERRED_SIZE, 339, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                        .addComponent(jLabel9, javax.swing.GroupLayout.PREFERRED_SIZE, 377, javax.swing.GroupLayout.PREFERRED_SIZE))))
                                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                                .addComponent(jLabel15)
                                                .addGap(18, 18, 18)
                                                .addComponent(jLabel16)
                                                .addGap(601, 601, 601))
                                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 897, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addGap(52, 52, 52))))
        );
        layout.setVerticalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                                .addContainerGap()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                        .addComponent(jLabel1)
                                        .addComponent(jLabel5))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(jLabel6)
                                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 66, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                        .addComponent(jLabel3)
                                        .addComponent(jLabel7))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addGroup(layout.createSequentialGroup()
                                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                                        .addComponent(labelNumPlaces)
                                                        .addComponent(numPlaces, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                                        .addComponent(jLabel2)
                                                        .addComponent(numTrans, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                                        .addComponent(labelIntMark)
                                                        .addComponent(initMarking, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                                .addComponent(button1))
                                        .addGroup(layout.createSequentialGroup()
                                                .addComponent(jLabel8)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                                .addComponent(jLabel9)
                                                .addGap(12, 12, 12)
                                                .addComponent(jLabel10)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(jLabel14)))
                                .addGap(21, 21, 21)
                                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                        .addComponent(jLabel4)
                                        .addComponent(jLabel12))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                        .addComponent(transEnterLabel)
                                        .addComponent(jLabel13))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                        .addComponent(transEnterField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(jLabel11))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(button2)
                                .addGap(7, 7, 7)
                                .addComponent(jSeparator3, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                        .addComponent(jLabel15)
                                        .addComponent(jLabel16))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 72, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void transEnterFieldActionPerformed(java.awt.event.ActionEvent evt)
    {//GEN-FIRST:event_transEnterFieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_transEnterFieldActionPerformed

    private void numTransActionPerformed(java.awt.event.ActionEvent evt)
    {//GEN-FIRST:event_numTransActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_numTransActionPerformed

    private void button2ActionPerformed(java.awt.event.ActionEvent evt)
    {//GEN-FIRST:event_button2ActionPerformed

        if(part1safe)
        {
            if(part3safe || part4safe)
            {



                if(part3safe)
                {
                    safeInput = false;
                    entering ++;
                    input = transEnterField.getText();
                    input = input.trim();

                    if(verify(input, noPlaces))
                    {
                        safeInput = true;
                        input = input.replace("(","");
                        input = input.replace(",", "");
                        input = input.replace(")", "");



                        String[] s;
                        s = input.split(delim);



                        for(int j=0; j<noPlaces; j++)
                        {
                            transIn[entering-1][j] = Integer.parseInt(s[j]);
                        }

                        if(entering == noTrans)
                        {
                            transEnterField.setText("");
                            part3safe = false;
                            part4safe = true;
                            entering =0;
                            transEnterLabel.setText("Please enter the outputs for Transition 1:  ");
                        }
                        else
                        {
                            transEnterField.setText("");
                            transEnterLabel.setText("Please enter the inputs for Transition " + (entering+1) + ":  ");
                        }
                    }
                    else
                    {
                        errorMes.setText("ERROR - Please enter your input in the format (int, int, . . . int)" +
                                "\nInclude only positive values and make sure you account for the correct number of places.");
                        entering --;
                    }
                }
                else
                {
                    safeInput = false;
                    entering ++;
                    input = transEnterField.getText();
                    input = input.trim();

                    if(verify(input, noPlaces))
                    {
                        safeInput = true;
                        input = input.replace("(","");
                        input = input.replace(",", "");
                        input = input.replace(")", "");



                        String[] s;
                        s = input.split(delim);



                        for(int j=0; j<noPlaces; j++)
                        {
                            transOut[entering-1][j] = Integer.parseInt(s[j]);
                        }

                        if(entering == noTrans)
                        {
                            transEnterField.setVisible(false);
                            part4safe = false;

                            calcMarkings();
                        }
                        else
                        {
                            transEnterField.setText("");
                            transEnterLabel.setText("Please enter the outputs for Transition " + (entering+1) + ":  ");
                        }
                    }
                    else
                    {
                        errorMes.setText("ERROR - Please enter your input in the format (int, int, . . . int)" +
                                "\nInclude only positive values and make sure you account for the correct number of places.");
                        entering --;
                    }
                }
            }
            else
                errorMes.setText("You have already entered all of the inputs and outputs for your transitions.");
        }
        else
        {
            errorMes.setText("Please complete part 1 before attempting part 2.");
        }


    }//GEN-LAST:event_button2ActionPerformed

    private void button1ActionPerformed(java.awt.event.ActionEvent evt)
    {//GEN-FIRST:event_button1ActionPerformed

        if(part0safe)
        {
            errorMes.setText("");

            if(getNumPlaces())
            {

                if(getNumTrans())
                {


                    if(!gotPT)
                    {
                        transIn = new int[noTrans][noPlaces];
                        transOut = new int[noTrans][noPlaces];


                        numPlaces.setVisible(false);
                        labelNumPlaces.setText("Places:  " + noPlaces);

                        jLabel2.setText("Transitions:  " + noTrans);
                        numTrans.setVisible(false);

                        gotPT = true;
                    }

                    getInit();
                }
            }
        }
        else
            errorMes.setText("You have already completed this part of the form, please move on to the next step.");

    }//GEN-LAST:event_button1ActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(PNCGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(PNCGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(PNCGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(PNCGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new PNCGUI().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton button1;
    private javax.swing.JButton button2;
    private javax.swing.JTextArea errorMes;
    private javax.swing.JTextField initMarking;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel16;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JSeparator jSeparator3;
    private javax.swing.JLabel labelIntMark;
    private javax.swing.JLabel labelNumPlaces;
    private javax.swing.JTextField numPlaces;
    private javax.swing.JTextField numTrans;
    private javax.swing.JTextArea reachableMarkings;
    private javax.swing.JTextField transEnterField;
    private javax.swing.JLabel transEnterLabel;



    //Regex definitions
    // static final String STATE =  "[(]?(\\d+, )*(\\d+)+[)]?";
    static final String POS_INT = "\\d+";





    //Variable Declarations
    Scanner in = new Scanner(System.in);
    String input;
    boolean safeInput=false;
    int noPlaces=0;
    int noTrans=0;
    boolean[] isEnabled;
    int transIn[][];
    int transOut[][];
    String delim = " ";
    ArrayList<String> markings = new ArrayList<String>();
    String currentMarkingAsString;
    int[] currentMarking;
    Iterator<String> iter;
    ArrayList<String> fired = new ArrayList<String>();
    ArrayList<String> toBeAdded = new ArrayList<String>();
    int entering;
    boolean part1safe;
    boolean part0safe;
    boolean part3safe;
    boolean part4safe;
    boolean gotPT;








    public void calcMarkings()
    {
        transEnterLabel.setText("Your Reachable Markings Are Being Generated Below");
        transEnterField.setVisible(false);

        do
        {
            iter = toBeAdded.iterator();
            while(iter.hasNext())
            {
                String add = iter.next();
                if(!markings.contains(add))
                    markings.add(add);
            }
            toBeAdded.clear();
            iter = markings.iterator();

            while(iter.hasNext())
            {
                //CHECKPOINT
                currentMarkingAsString = iter.next();
                if(!fired.contains(currentMarkingAsString))
                {
                    fired.add(currentMarkingAsString);
                    currentMarking = convertMarking(currentMarkingAsString);
                    checkEnabled(currentMarking);
                    for(int i=0; i<noTrans; i++)
                    {
                        //CHECKPOINT
                        if(isEnabled[i])
                        {
                            //CHECKPOINT
                            runMarking(currentMarking, i);
                        }
                    }


                    //CHECKPOINT - DEBUG
                }
            }
        }while(!toBeAdded.isEmpty());


        Iterator<String> printer = markings.iterator();
        String output;

        if(printer.hasNext())
        {
            output=("The following markings are reachable:  " +
                    "\n---------------------------------------");
            reachableMarkings.setText(output);

            while(printer.hasNext())
            {
                output = output + "\n" + replaceNegs(printer.next());
                reachableMarkings.setText(output);
            }
        }
        else {
            output=("No additional markings were reachable.\n Thank you for using Justonicete, the reachability calculator you can rely on, " +
                    "\nand that was brought to you because it was mandatory.");
            reachableMarkings.setText(output);
        }


        in.close();
    }







    //This method runs through each transition and, given some marking, checks whether or not its preconditions are met, thus determing whether not each one is enabled.
    public void checkEnabled(int[] marking)
    {

        for(int i=0; i<noTrans; i++)
        {
            for(int j=0; j<noPlaces; j++)
            {
                //go through each place for the current marking and current transition. If at any point part of its precondition is not met it stops checking and moves on to the next transition.
                //if it makes it through every transition without "kicking out" it is enabled by the statement isEnabled[i] = true;
                if(transIn[i][j] > marking[j] && marking[j] != -1)
                {
                    isEnabled[i] = false;
                    j = noPlaces;
                }

                if(j == noPlaces - 1)
                {
                    isEnabled[i] = true;
                }
            }
        }

    }





    //String s is any string (the input variable is expected) and String reg is a regular expression (a predefined regex variable is expected)
    private static boolean verify(String s, String reg)
    {
        if(s.matches(reg))
            return true;
        else
            return false;
    }





    //String s is any string (input variable is expected) and int num is any number (noPlaces variable is expected)
    //Method checks a string to make sure it is the in appropriate format for a state OR Transition IO ex:  (W, X, Y, Z)
    //It also makes sure that it has the correct number of places determined by "int num"
    //Typical call would look like verify(input, noPlaces) which will make sure that the input is in the appropriate format
    //  and accounts for the correct number of places
    private boolean verify(String s, int num)
    {
        String tempReg = "[(]?((\\d+, )|(\\d+ )){"+(num-1)+"}(\\d+)+[)]?";

        if(s.matches(tempReg))
            return true;
        else
            return false;
    }





    //Method asks for and stores initial Marking
    private void getInit()
    {


        safeInput = false;

            input = initMarking.getText();

            //NEWEST - CHECKPOINT
            input = input.trim();

            if(verify(input, noPlaces))
            {
                safeInput = true;

                input = convertInitial(input);
                markings.add(input);
                part1safe = true;
                part0safe = false;

                labelIntMark.setText("Initial Marking:  " + input);
                initMarking.setVisible(false);
                transEnterLabel.setText("Please enter the inputs for Transition 1:  ");
            }
            else
                errorMes.setText("ERROR - Please enter your marking in the format (int, int, . . . int)" +
                        "\nInclude only positive values and make sure you account for the correct number of places.");

    }





    //Method converts markings into an array of integers for usability
    private int[] convertMarking(String in)
    {

        in = in.replace("(","");
        in = in.replace(",", "");
        in = in.replace(")", "");

        String[] s;
        s = in.split(delim);
        int[] temp = new int[noPlaces];
        for(int i=0; i<noPlaces; i++)
        {
            temp[i] = Integer.parseInt(s[i]);
        }


        return temp.clone();
    }





    //Converts the initial marking to the format (int, int, . . . int)
    private String convertInitial(String in)
    {
        int[] raw = convertMarking(in);
        String retVal = "(" + raw[0];

        for(int i=1; i<raw.length; i++)
        {
            retVal = retVal + ", " + raw[i];
        }
        retVal = retVal + ")";

        return retVal;
    }





    //Method finds runs through the ArrayList markings and uses the markings within it to create a new markings until no
    //unique markings are generated.
    private void runMarking(int[] marking, int trans)
    {
        String newMarking;
        if(marking[0] != -1)
            newMarking=""+(marking[0] - transIn[trans][0] + transOut[trans][0]);
        else
            newMarking="-1";

        for(int i=1; i<noPlaces; i++)
        {
            if(marking[i] != -1)
                newMarking = newMarking + ", " + (marking[i] - transIn[trans][i] + transOut[trans][i]);
            else
                newMarking = newMarking + ", " + "-1";
        }


        //CHECKPOINT - LOOK HERE
        newMarking = convertInitial(newMarking);

        Iterator<String> it = markings.iterator();
        boolean unique=true;
        while(it.hasNext())
        {
            try
            {
                String oldMarking = it.next();


                if(newMarking.compareTo(oldMarking) != 0)
                {

                    int[] old = convertMarking(oldMarking);

                    int[] deltaM = calcDelta(old, convertMarking(newMarking));



                    int noOfZero = 0;

                    for(int i=0; i<noPlaces; i++)
                    {
                        if(deltaM[i] == 0)
                        {
                            noOfZero ++;
                        }
                    }

                    if(noOfZero == noPlaces)
                        unique=false;



                    if(unique)
                    {
                        int numberOfPos = 0;
                        int numberOfNeg = 0;

                        for( int i=0; i<noPlaces; i++)
                        {
                            if(deltaM[i] > 0)
                                numberOfPos ++;
                            if(deltaM[i] < 0)
                                numberOfNeg ++;
                            if(numberOfNeg > 0)
                                break;
                        }

                        if(numberOfNeg == 0 && numberOfPos > 0)
                        {
                            int [] replacement = convertMarking(newMarking);
                            calcOmega(deltaM, replacement);


                            newMarking = "(" + replacement[0];

                            for(int i=1; i<noPlaces; i++)
                            {
                                newMarking = newMarking + ", " + replacement[i];
                            }
                            newMarking = newMarking + ")";
                        }
                    }
                }

                //CHECKPOINT
            }
            catch(Exception e)
            {
                continue;
            }

        }

        //ADD MARKINGS HERE
        if(unique)
            if(!toBeAdded.contains(convertInitial(newMarking)));
        toBeAdded.add(convertInitial(newMarking));
    }





    //Calculates the difference between two markings placewise
    private int[] calcDelta(int[] oldMark, int[] newMark)
    {
        int[] retValue = new int[noPlaces];

        for(int i=0; i<noPlaces; i++)
        {
            if(oldMark[i] == -1)
            {
                retValue[i] = 0; //represents an omega token at one of the positions
            }
            else
                retValue[i] = newMark[i] - oldMark[i];
        }

        return retValue.clone();
    }





    //Calculates omega tokens (-1)
    private void calcOmega(int[] delta, int[] newMark)
    {
        for(int i=0; i<noPlaces; i++)
            if(delta[i] > 0)
                newMark[i] = -1;
    }





    //Process Transout
    private void processTransOut()
    {
        for(int i=0; i < noTrans; i++)
        {
            safeInput = false;
            do
            {
                 transEnterLabel.setText("Please enter the outputs for Transition " + (i+1) +":  ");
                input = in.nextLine();


                //NEWEST - CHECKPOINT
                input = input.trim();

                if(verify(input, noPlaces))
                {
                    safeInput = true;

                    input = input.replace("(","");
                    input = input.replace(",", "");
                    input = input.replace(")", "");



                    String[] s;
                    s = input.split(delim);



                    for(int j=0; j<noPlaces; j++)
                    {
                        transOut[i][j] = Integer.parseInt(s[j]);
                    }
                }
                else
                   errorMes.setText("ERROR - Please enter your marking in the format (int, int, . . . int)" +
                            "\nInclude only positive values and make sure you account for the correct number of places.");
            }while(!safeInput);
        }
    }





    //Get Number of Places
    private boolean getNumPlaces()
    {
            input = numPlaces.getText();

            //NEWEST - CHECKPOINT
            input = input.trim();

            if(verify(input, POS_INT))
                safeInput = true;
            else
            {
                errorMes.setText("ERROR - Please enter a positive integer for number of places!" );
                return false;
            }

        //Create Places
        if(safeInput)
            noPlaces = Integer.parseInt(input);

        return true;
    }





    //Get number of trans
    private boolean getNumTrans()
    {
        safeInput = false;

            input = numTrans.getText();

            //NEWEST - CHECKPOINT
            input = input.trim();

            if(verify(input, POS_INT))
                safeInput = true;
            else
            {
                errorMes.setText("ERROR - Please enter a positive integer for number of Transitions!");
                return false;
            }



        //Create Transitions
        if(safeInput)
        {
            noTrans = Integer.parseInt(input);
            isEnabled = new boolean[noTrans];
        }
        return true;
    }





    //takes a postcondition and determines whether or not each transition is enabled
    public void enabledChecker(String marking)
    {

    }





    public String replaceNegs(String s)
    {
        return s.replace("-1", "w");
    }
}







    //Process transIn


